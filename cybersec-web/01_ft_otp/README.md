## Cybersecurity Traine ft_opt

In the language of your choice, you have to implement a program that allows you to store an initial password in file, and that is capable of generating a new one time password every time it is requested.

You can use any library that facilitates the implementation of the algorithm, as long as it doesn’t do the dirty work, i.e. using a TOTP library is strictly prohibited.
Of course, you can and should use a library or function that allows you to access system time.

In this project, the aim is to implement a TOTP (Time-based One-Time Password) system, which will be capable of generating ephemeral passwords from a master key.
It will be based on the RFC: https://datatracker.ietf.org/doc/html/rfc6238, so you could use it in your day to day.


• Your program must take arguments.
◦ -g: The program receives as argument a hexadecimal key of at least 64 characters. The program stores this key safely in a file called ft_otp.key, which is encrypted.
◦ -k: The program generates a new temporary password based on the key given
as argument and prints it on the standard output.
• Your program must use the HOTP algorithm (RFC 4226) https://datatracker.ietf.org/doc/html/rfc4226 .
• The generated one-time password must be random and must always contain the same format, i.e. 6 digits.

Bonus Part: 
- Creation of a QR code with seed generation.
- Creation of a graphic interface

Below is an example of use:
$ echo -n "NEVER GONNA GIVE YOU UP" > key.txt
$ ./ft_otp -g key.txt
./ft_otp: error: key must be 64 hexadecimal characters.
$ [..]
$ cat key.hex | wc -c
64
$ ./ft_otp -g key.hex
Key was successfully saved in ft_otp.key.
$ ./ft_otp -k ft_otp.key
836492
$ sleep 60
$ ./ft_otp -k ft_otp.key
123518
4

You can check if your program is working properly by comparing generated passwords with Oathtool or any tool of your choice.

!! oathtool –totp $(cat key.hex)

tp -dc a-zA-Z0-9 < /dev/urandom | head -c 12

**-------------------------------------------------------------------**

Reference:
https://medium.com/@short_sparrow/how-hmac-works-step-by-step-explanation-with-examples-f4aff5efb40e

https://mdamiruddin.medium.com/introduction-to-cryptography-tryhackme-writeup-walkthrough-75a1a198b973


https://datatracker.ietf.org/doc/html/rfc6238
https://datatracker.ietf.org/doc/html/rfc4226#page-3
https://datatracker.ietf.org/doc/html/rfc2104

https://en.wikipedia.org/wiki/HMAC
https://en.wikipedia.org/wiki/HMAC-based_one-time_password
https://www.geeksforgeeks.org/python-add-trailing-zeros-to-string/
https://www.geeksforgeeks.org/hashlib-module-in-python/
https://www.geeksforgeeks.org/passing-function-as-an-argument-in-python/

Here is a list of symbols used in this document.

Symbol  Represents
-------------------------------------------------------------------
C       8-byte counter value, the moving factor.  This counter
        MUST be synchronized between the HOTP generator (client)
        and the HOTP validator (server).

K       shared secret between client and server; each HOTP
        generator has a different and unique secret K.

T       throttling parameter: the server will refuse connections
        from a user after T unsuccessful authentication attempts.

s       resynchronization parameter: the server will attempt to
        verify a received authenticator across s consecutive
        counter values.

Digit   number of digits in an HOTP value; system parameter.

**HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))**

where:
- Truncate represents the function that converts an HMAC-SHA-1
       value into an HOTP value as defined in Section 5.3.

The Key (K), the Counter (C), and Data values are hashed high-order
   byte first.

The HOTP values generated by the HOTP generator are treated as big
   endian.


- - Generating an HOTP Value:

Step 1: Generate an HMAC-SHA-1 value Let **HS = HMAC-SHA-1(K,C)**  // HS is a 20-byte string

Step 2: Generate a 4-byte string (Dynamic Truncation)
Let **Sbits = DT(HS)**   //  DT, defined below,
                    //  returns a 31-bit string

Step 3: Compute an HOTP value
Let **Snum  = StToNum(Sbits)**   // Convert S to a number in
                                0...2^{31}-1
Return **D = Snum mod 10^Digit** //  D is a number in the range
                                0...10^{Digit}-1

StToNum(110) = 6

DT(String) // String = String[0]...String[19]
Let OffsetBits be the low-order 4 bits of String[19]
Offset = StToNum(OffsetBits) // 0 <= OffSet <= 15
Let P = String[OffSet]...String[OffSet+3]
Return the Last 31 bits of P
